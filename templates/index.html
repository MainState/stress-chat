<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>AI ëŒ€í™”í˜• ìŠ¤íŠ¸ë ˆìŠ¤ ìê°€ ì„±ì°° ë„ìš°ë¯¸</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div id="app-container">
        <div id="welcome-section">
            <h1>AI ëŒ€í™”í˜• ìŠ¤íŠ¸ë ˆìŠ¤ ìê°€ ì„±ì°° ë„ìš°ë¯¸</h1>

            <section>
                <h2>í”„ë¡œê·¸ë¨ì˜ ëª©ì </h2>
                <p>ë³¸ í”„ë¡œê·¸ë¨ì€ ì‚¬ìš©ìê°€ AI ì±—ë´‡ê³¼ì˜ í¸ì•ˆí•œ ëŒ€í™”ë¥¼ í†µí•´ ìµœê·¼ ìì‹ ì˜ ìŠ¤íŠ¸ë ˆìŠ¤ ìˆ˜ì¤€ì„ ìŠ¤ìŠ¤ë¡œ ëŒì•„ë³´ê³  ì„±ì°°í•  ìˆ˜ ìˆë„ë¡ ë•ê¸° ìœ„í•´ ê°œë°œë˜ì—ˆìŠµë‹ˆë‹¤.</p>
                <p>ì•½ 20í„´ì˜ ì§§ì€ ëŒ€í™”ë¥¼ í†µí•´ í˜„ì¬ ëŠë¼ëŠ” ê°ì •, ì¼ìƒì—ì„œì˜ ê²½í—˜, ì‹ ì²´ì  ë°˜ì‘ ë“±ì„ íƒìƒ‰í•©ë‹ˆë‹¤.</p>
                <p class="warning"><strong>ì£¼ì˜:</strong> ì´ í”„ë¡œê·¸ë¨ì€ ì¬ë¯¸ ë˜ëŠ” ì°¸ê³ ìš©ì´ë©°, ì˜í•™ì  ì§„ë‹¨ì´ë‚˜ ì „ë¬¸ì ì¸ ì‹¬ë¦¬ ìƒë‹´ì„ ëŒ€ì²´í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‹¬ê°í•œ ìŠ¤íŠ¸ë ˆìŠ¤ë‚˜ ì •ì‹  ê±´ê°• ë¬¸ì œê°€ ì˜ì‹¬ë  ê²½ìš° ë°˜ë“œì‹œ ì „ë¬¸ê°€ì™€ ìƒë‹´í•˜ì„¸ìš”.</p>
            </section>

            <section>
                <h2>ìŠ¤íŠ¸ë ˆìŠ¤ ì¸¡ì • ë°©ë²•</h2>
                <p>ì±—ë´‡ê³¼ì˜ ëŒ€í™”ì—ì„œ ì‚¬ìš©ìê°€ ì‚¬ìš©í•˜ëŠ” ë‹¨ì–´ì™€ í‘œí˜„ì„ ë¶„ì„í•˜ì—¬ ìŠ¤íŠ¸ë ˆìŠ¤ ìˆ˜ì¤€ì„ ì¶”ì •í•©ë‹ˆë‹¤.</p>
                <p>ì‹œìŠ¤í…œì€ ë‹¤ì–‘í•œ ìŠ¤íŠ¸ë ˆìŠ¤ ê´€ë ¨ ì¹´í…Œê³ ë¦¬(ì˜ˆ: ì •ì„œì  ì–´ë ¤ì›€, ì—…ë¬´/í•™ì—… ë¶€ë‹´, ëŒ€ì¸ ê´€ê³„, ì‹ ì²´ ì¦ìƒ ë“±)ì— í•´ë‹¹í•˜ëŠ” í‚¤ì›Œë“œë“¤ì˜ ì¶œí˜„ ë¹ˆë„ì™€ ë¯¸ë¦¬ ì •ì˜ëœ ê°€ì¤‘ì¹˜ë¥¼ ì¢…í•©ì ìœ¼ë¡œ ê³ ë ¤í•©ë‹ˆë‹¤.</p>
                <p>ëŒ€í™”ê°€ ì¢…ë£Œë˜ë©´, ë¶„ì„ëœ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ 1.0ì ì—ì„œ 10.0ì  ì‚¬ì´ì˜ ì¢…í•©ì ì¸ ìŠ¤íŠ¸ë ˆìŠ¤ ì¶”ì • ì ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤.</p>
            </section>

            <section>
                <h2>ì¸¡ì • ë°©ë²•ì˜ ê³¼í•™ì  ê·¼ê±°</h2>
                <p>ë³¸ ì¸¡ì • ë°©ì‹ì€ 'ì‚¬ëŒì˜ ì–¸ì–´ ì‚¬ìš©ì´ ì‹¬ë¦¬ ìƒíƒœë¥¼ ë°˜ì˜í•œë‹¤'ëŠ” ì‹¬ë¦¬ì–¸ì–´í•™ ë° ë‚´ìš© ë¶„ì„ ì—°êµ¬ ì›ë¦¬ì— ê¸°ë°˜í•©ë‹ˆë‹¤.</p>
                <p>íŠ¹íˆ, ì‹¬ë¦¬í•™ ì—°êµ¬ì—ì„œ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” LIWC(Linguistic Inquiry and Word Count)ì™€ ê°™ì´, í…ìŠ¤íŠ¸ ë‚´ íŠ¹ì • ë‹¨ì–´ ì¹´í…Œê³ ë¦¬ì˜ ë¹ˆë„ë¥¼ í†µí•´ ì‹¬ë¦¬ ìƒíƒœë¥¼ ì¶”ë¡ í•˜ëŠ” ì „ë¬¸ì ì¸ ë°©ë²•ë¡ ì˜ í•µì‹¬ ì•„ì´ë””ì–´ë¥¼ ì°¸ê³ í•˜ì—¬, ë³¸ í”„ë¡œì íŠ¸ì˜ ëª©ì ì— ë§ê²Œ ë‹¨ìˆœí™”í•˜ê³  ì‘ìš©í•˜ì˜€ìŠµë‹ˆë‹¤.</p>
            </section>

            <button id="start-chat-button">ì±„íŒ… ì‹œì‘í•˜ê¸°</button>
        </div>

        <div id="chat-section" style="display: none;">
            <h1>ìŠ¤íŠ¸ë ˆìŠ¤ í‰ê°€ ëŒ€í™”</h1>
            <div id="chat-box"></div>
            <div id="input-area">
                <input type="text" id="user-input" placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”...">
                <button id="send-button">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                    </svg>
                </button>
            </div>
            <div id="turn-indicator" style="margin-bottom: 5px; font-size: 0.9em; color: grey;">ëŒ€í™” ì‹œì‘ ì¤‘...</div>
            <div id="score-display"></div>
        </div>

        <div id="results-section" style="display: none;">
            <h2>ìµœì¢… ìŠ¤íŠ¸ë ˆìŠ¤ í‰ê°€ ê²°ê³¼</h2>
            <p id="final-score-value"></p>
            <p class="disclaimer">ë³¸ ì ìˆ˜ëŠ” ì°¸ê³ ìš©ì´ë©° ì˜í•™ì  ì§„ë‹¨ì„ ëŒ€ì²´í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.<br>ì „ë¬¸ì ì¸ ìƒë‹´ì´ í•„ìš”í•˜ì‹œë‹¤ë©´ ì „ë¬¸ê°€ì™€ ìƒë‹´í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.</p>
            <button id="try-again-button">ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•˜ê¸°</button>
        </div>
    </div>

    <script>
        const welcomeSection = document.getElementById('welcome-section');
        const chatSection = document.getElementById('chat-section');
        const resultsSection = document.getElementById('results-section');
        const chatBox = document.getElementById('chat-box');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const turnIndicator = document.getElementById('turn-indicator');
        const scoreDisplay = document.getElementById('score-display');
        const finalScoreValueElement = document.getElementById('final-score-value');
        const startChatButton = document.getElementById('start-chat-button');
        const tryAgainButton = document.getElementById('try-again-button');

        startChatButton.addEventListener('click', () => {
            welcomeSection.style.display = 'none';
            chatSection.style.display = 'block';
            userInput.focus();
        });

        tryAgainButton.addEventListener('click', () => {
            window.location.href = '/';
        });

        async function sendMessage() {
            const userMessage = userInput.value.trim();
            if (userMessage === "") {
                return;
            }

            userInput.value = "";

            const cheatCodeMatch = userMessage.match(/^\/setturn\s+(\d+)$/);
            const setScoreCheatMatch = userMessage.match(/^\/setscore\s+([1-9]|10)$/);

            // Helper function to handle loading indicator
            function addLoadingIndicator() {
                const loadingIndicator = document.createElement('div');
                loadingIndicator.id = 'loading-indicator';
                loadingIndicator.className = 'message-container bot-message-container loading-message';
                const messageElement = document.createElement('div');
                messageElement.className = 'bot-message';
                messageElement.textContent = 'AIê°€ ìƒê° ì¤‘ì´ì—ìš”...';
                loadingIndicator.appendChild(messageElement);
                chatBox.appendChild(loadingIndicator);
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            function removeLoadingIndicator() {
                const existingLoadingIndicator = document.getElementById('loading-indicator');
                if (existingLoadingIndicator) {
                    existingLoadingIndicator.remove();
                }
            }

            if (cheatCodeMatch) {
                console.log("Frontend: CHEAT CODE detected. Processing for cheat path...");

                const targetTurn = parseInt(cheatCodeMatch[1], 10);
                const payload = {
                    cheat_command: "set_turn",
                    target_turn: targetTurn
                };
                console.log("Frontend: Sending CHEAT payload to backend:", payload);

                try {
                    const response = await fetch('/send_message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    console.log("Frontend: Received response for CHEAT command from backend:", data);

                    chatBox.innerHTML = '';

                    if (data.reply) {
                        const systemMessageP = document.createElement('p');
                        systemMessageP.innerHTML = `<strong>[ì‹œìŠ¤í…œ]</strong> ${data.reply}`;
                        chatBox.appendChild(systemMessageP);
                    }

                    if (turnIndicator && data.current_turn !== undefined && data.max_turns !== undefined) {
                        turnIndicator.textContent = `í˜„ì¬ ì§„í–‰: ${data.current_turn} / ${data.max_turns} í„´`;
                    }

                    // Only show score in final results, not during conversation
                    if (data.conversation_end === true) {
                        console.log("Frontend: CHEAT caused conversation end. Switching to results screen.");
                        chatSection.style.display = 'none';
                        resultsSection.style.display = 'block';
                        const finalScore = typeof data.stress_score === 'object' ? 
                            (data.stress_score.overall_score || 5.0) : 
                            data.stress_score;
                        finalScoreValueElement.textContent = finalScore.toFixed(1) + "ì ";
                        if (turnIndicator) turnIndicator.textContent = "ëŒ€í™” ì¢…ë£Œë¨";
                        userInput.disabled = true;
                        sendButton.disabled = true;
                    } else {
                        userInput.disabled = false;
                        sendButton.disabled = false;
                    }

                } catch (error) {
                    console.error('Frontend: Error processing CHEAT command:', error);
                    const errorP = document.createElement('p');
                    errorP.textContent = `ì¹˜íŠ¸ ì½”ë“œ ì²˜ë¦¬ ì˜¤ë¥˜: ${error.message}`;
                    errorP.style.color = 'red';
                    chatBox.appendChild(errorP);
                }

            } else if (setScoreCheatMatch) {
                console.log("Frontend: SET_SCORE CHEAT detected. Processing...");
                const targetScore = parseInt(setScoreCheatMatch[1], 10);

                if (targetScore < 1 || targetScore > 10) {
                    const errorP = document.createElement('p');
                    errorP.textContent = "ì˜¤ë¥˜: ìŠ¤íŠ¸ë ˆìŠ¤ ì ìˆ˜ëŠ” 1ì—ì„œ 10 ì‚¬ì´ì˜ ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤.";
                    errorP.style.color = 'red';
                    chatBox.appendChild(errorP);
                    return;
                }

                const payload = {
                    cheat_command: "set_score",
                    target_score: targetScore
                };

                try {
                    const response = await fetch('/send_message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    console.log("Frontend: Received response for SET_SCORE command:", data);

                    if (data.reply) {
                        const systemMessageP = document.createElement('p');
                        systemMessageP.innerHTML = `<strong>[ì‹œìŠ¤í…œ]</strong> ${data.reply}`;
                        chatBox.appendChild(systemMessageP);
                    }

                    if (turnIndicator && data.current_turn !== undefined && data.max_turns !== undefined) {
                        turnIndicator.textContent = `í˜„ì¬ ì§„í–‰: ${data.current_turn} / ${data.max_turns} í„´`;
                    }

                    // Only show score in final results, not during conversation
                    if (data.conversation_end === true) {
                        chatSection.style.display = 'none';
                        resultsSection.style.display = 'block';
                        const finalScore = typeof data.stress_score === 'object' ? 
                            (data.stress_score.overall_score || 5.0) : 
                            data.stress_score;
                        finalScoreValueElement.textContent = finalScore.toFixed(1) + "ì ";
                        if (turnIndicator) turnIndicator.textContent = "ëŒ€í™” ì¢…ë£Œë¨";
                        userInput.disabled = true;
                        sendButton.disabled = true;
                    } else {
                        userInput.disabled = false;
                        sendButton.disabled = false;
                    }

                } catch (error) {
                    console.error('Frontend: Error processing SET_SCORE command:', error);
                    const errorP = document.createElement('p');
                    errorP.textContent = `ì¹˜íŠ¸ ì½”ë“œ ì²˜ë¦¬ ì˜¤ë¥˜: ${error.message}`;
                    errorP.style.color = 'red';
                    chatBox.appendChild(errorP);
                }

            } else {
                console.log("Frontend: NORMAL message detected. Sending:", userMessage);

                const container = document.createElement('div');
                container.classList.add('message-container', 'user-message-container');
                const messageElement = document.createElement('div');
                messageElement.classList.add('user-message');
                messageElement.textContent = userMessage;
                container.appendChild(messageElement);
                chatBox.appendChild(container);
                chatBox.scrollTop = chatBox.scrollHeight;

                addLoadingIndicator();

                try {
                    const response = await fetch('/send_message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ message: userMessage })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    removeLoadingIndicator();
                    console.log("Frontend: Received response for NORMAL command from backend:", data);
                    console.log("DEBUG: Backend Response Data Received:", JSON.stringify(data, null, 2));

                    if (data.reply) {
                        const container = document.createElement('div');
                        container.classList.add('message-container', 'bot-message-container');

                        const avatar = document.createElement('div');
                        avatar.classList.add('chatbot-avatar');
                        avatar.innerHTML = 'ğŸ¤–';
                        container.appendChild(avatar);

                        const messageElement = document.createElement('div');
                        messageElement.classList.add('bot-message');
                        messageElement.textContent = data.reply;
                        container.appendChild(messageElement);
                    }

                    if (turnIndicator && data.current_turn !== undefined && data.max_turns !== undefined) {
                        turnIndicator.textContent = `í˜„ì¬ ì§„í–‰: ${data.current_turn} / ${data.max_turns} í„´`;
                    }

                    // Only show score in final results, not during conversation
                    if (data.conversation_end === true) {
                        chatSection.style.display = 'none';
                        resultsSection.style.display = 'block';
                        const finalScore = typeof data.stress_score === 'object' ? 
                            (data.stress_score.overall_score || 5.0) : 
                            data.stress_score;
                        finalScoreValueElement.textContent = finalScore.toFixed(1) + "ì ";
                        if (turnIndicator) turnIndicator.textContent = "ëŒ€í™” ì¢…ë£Œë¨";
                        userInput.disabled = true;
                        sendButton.disabled = true;
                    } else {
                        userInput.disabled = false;
                        sendButton.disabled = false;
                    }

                } catch (error) {
                    removeLoadingIndicator();
                    console.error('Frontend: Error processing NORMAL command:', error);
                    const errorP = document.createElement('p');
                    errorP.textContent = `ì˜¤ë¥˜: ${error.message}`;
                    errorP.style.color = 'red';
                    chatBox.appendChild(errorP);
                }
            }
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        sendButton.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        // Hide the score display element initially
        document.getElementById('score-display').style.display = 'none';
    </script>
</body>
</html>