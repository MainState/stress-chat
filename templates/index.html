<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>스트레스 평가 대화</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div id="app-container">
        <h1>스트레스 평가 대화</h1>
        <div id="chat-section">
            <div id="chat-box"></div>
            <div id="input-area">
                <input type="text" id="user-input" placeholder="메시지를 입력하세요...">
                <button id="send-button">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                    </svg>
                </button>
            </div>
            <div id="turn-indicator" style="margin-bottom: 5px; font-size: 0.9em; color: grey;">대화 시작 중...</div>
            <div id="score-display"></div>
        </div>

        <div id="results-section" style="display: none;">
            <h2>최종 스트레스 평가 결과</h2>
            <p id="final-score-value"></p>
            <div id="category-scores-details" class="category-scores">
                <h3>카테고리별 세부 점수</h3>
                <div class="scores-grid"></div>
            </div>
            <p class="disclaimer">본 점수는 참고용이며 의학적 진단을 대체할 수 없습니다.<br>전문적인 상담이 필요하시다면 전문가와 상담하시기 바랍니다.</p>
            <button id="try-again-button">처음부터 다시 시작하기</button>
        </div>
    </div>

    <script>
        const chatSection = document.getElementById('chat-section');
        const resultsSection = document.getElementById('results-section');
        const chatBox = document.getElementById('chat-box');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const turnIndicator = document.getElementById('turn-indicator');
        const scoreDisplay = document.getElementById('score-display');
        const finalScoreValueElement = document.getElementById('final-score-value');
        const tryAgainButton = document.getElementById('try-again-button');

        async function sendMessage() {
            const userMessage = userInput.value.trim();
            if (userMessage === "") {
                return;
            }

            console.log("Frontend: User input received:", userMessage);

            const cheatCodeMatch = userMessage.match(/^\/setturn\s+(\d+)$/);
            const setScoreCheatMatch = userMessage.match(/^\/setscore\s+([1-9]|10)$/);
            console.log("Frontend: Cheat code match result:", cheatCodeMatch);
            console.log("Frontend: SetScore cheat match result:", setScoreCheatMatch);

            userInput.value = "";

            if (cheatCodeMatch) {
                console.log("Frontend: CHEAT CODE detected. Processing for cheat path...");

                const targetTurn = parseInt(cheatCodeMatch[1], 10);
                const payload = {
                    cheat_command: "set_turn",
                    target_turn: targetTurn
                };
                console.log("Frontend: Sending CHEAT payload to backend:", payload);

                try {
                    const response = await fetch('/send_message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    console.log("Frontend: Received response for CHEAT command from backend:", data);

                    chatBox.innerHTML = '';

                    if (data.reply) {
                        const systemMessageP = document.createElement('p');
                        systemMessageP.innerHTML = `<strong>[시스템]</strong> ${data.reply}`;
                        chatBox.appendChild(systemMessageP);
                    }

                    if (turnIndicator && data.current_turn !== undefined && data.max_turns !== undefined) {
                        turnIndicator.textContent = `현재 진행: ${data.current_turn} / ${data.max_turns} 턴`;
                    }

                    if (scoreDisplay && data.stress_score !== undefined) {
                        scoreDisplay.textContent = `현재 추정 스트레스 점수: ${data.stress_score} / 10`;
                    }

                    if (data.conversation_end === true) {
                        console.log("Frontend: CHEAT caused conversation end. Switching to results screen.");
                        chatSection.style.display = 'none';
                        resultsSection.style.display = 'block';
                        finalScoreValueElement.textContent = data.stress_score + "점";
                        if (turnIndicator) turnIndicator.textContent = "대화 종료됨";
                        userInput.disabled = true;
                        sendButton.disabled = true;
                    } else {
                        userInput.disabled = false;
                        sendButton.disabled = false;
                    }

                } catch (error) {
                    console.error('Frontend: Error processing CHEAT command:', error);
                    const errorP = document.createElement('p');
                    errorP.textContent = `치트 코드 처리 오류: ${error.message}`;
                    errorP.style.color = 'red';
                    chatBox.appendChild(errorP);
                }

            } else if (setScoreCheatMatch) {
                console.log("Frontend: SET_SCORE CHEAT detected. Processing...");
                const targetScore = parseInt(setScoreCheatMatch[1], 10);

                if (targetScore < 1 || targetScore > 10) {
                    const errorP = document.createElement('p');
                    errorP.textContent = "오류: 스트레스 점수는 1에서 10 사이의 값이어야 합니다.";
                    errorP.style.color = 'red';
                    chatBox.appendChild(errorP);
                    return;
                }

                const payload = {
                    cheat_command: "set_score",
                    target_score: targetScore
                };

                try {
                    const response = await fetch('/send_message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    console.log("Frontend: Received response for SET_SCORE command:", data);

                    if (data.reply) {
                        const systemMessageP = document.createElement('p');
                        systemMessageP.innerHTML = `<strong>[시스템]</strong> ${data.reply}`;
                        chatBox.appendChild(systemMessageP);
                    }

                    if (turnIndicator && data.current_turn !== undefined && data.max_turns !== undefined) {
                        turnIndicator.textContent = `현재 진행: ${data.current_turn} / ${data.max_turns} 턴`;
                    }

                    if (data.conversation_end === true) {
                        chatSection.style.display = 'none';
                        resultsSection.style.display = 'block';

                        // 전체 점수 표시
                        const overallScore = data.stress_score.overall_score || data.stress_score;
                        finalScoreValueElement.textContent = overallScore + "점";

                        // 카테고리별 점수 표시
                        const scoresGrid = document.querySelector('#category-scores-details .scores-grid');
                        scoresGrid.innerHTML = '';

                        if (data.stress_score.category_scores) {
                            const categoryNames = {
                                'negative_emotion': '부정적 감정',
                                'positive_emotion': '긍정적 감정',
                                'sleep_issues': '수면 문제',
                                'workload_issues': '업무/학업 부담',
                                'physical_symptoms': '신체적 증상',
                                'interpersonal_stress': '대인관계 스트레스',
                                'future_anxiety': '미래 불안',
                                'low_self_esteem': '자존감 저하'
                            };

                            for (const [category, score] of Object.entries(data.stress_score.category_scores)) {
                                const scoreItem = document.createElement('div');
                                scoreItem.className = 'score-item';
                                scoreItem.innerHTML = `
                                    <div class="category-name">${categoryNames[category] || category}</div>
                                    <div class="score-value">${score.toFixed(1)} / 5.0</div>
                                `;
                                scoresGrid.appendChild(scoreItem);
                            }
                        }

                        if (turnIndicator) turnIndicator.textContent = "대화 종료됨";
                        userInput.disabled = true;
                        sendButton.disabled = true;
                    } else {
                        userInput.disabled = false;
                        sendButton.disabled = false;
                    }

                } catch (error) {
                    console.error('Frontend: Error processing SET_SCORE command:', error);
                    const errorP = document.createElement('p');
                    errorP.textContent = `치트 코드 처리 오류: ${error.message}`;
                    errorP.style.color = 'red';
                    chatBox.appendChild(errorP);
                }

            } else {
                console.log("Frontend: NORMAL message detected. Sending:", userMessage);

                const container = document.createElement('div');
                container.classList.add('message-container', 'user-message-container');
                const messageElement = document.createElement('div');
                messageElement.classList.add('user-message');
                messageElement.textContent = userMessage;
                container.appendChild(messageElement);
                chatBox.appendChild(container);
                chatBox.scrollTop = chatBox.scrollHeight;

                try {
                    const response = await fetch('/send_message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ message: userMessage })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    console.log("Frontend: Received response for NORMAL command from backend:", data);

                    if (data.reply) {
                        const container = document.createElement('div');
                        container.classList.add('message-container', 'bot-message-container');
                        const messageElement = document.createElement('div');
                        messageElement.classList.add('bot-message');
                        messageElement.textContent = data.reply;
                        container.appendChild(messageElement);
                        chatBox.appendChild(container);
                    }

                    if (turnIndicator && data.current_turn !== undefined && data.max_turns !== undefined) {
                        turnIndicator.textContent = `현재 진행: ${data.current_turn} / ${data.max_turns} 턴`;
                    }

                    console.log("DEBUG: Backend Response Data Received:", JSON.stringify(data, null, 2));
                    
                    if (data.conversation_end === true) {
                        console.log("Frontend: Conversation ended. Switching to results screen.");
                        chatSection.style.display = 'none';
                        resultsSection.style.display = 'block';

                        // 종합 점수 표시
                        console.log("DEBUG: Setting final overall score:", data.scores.overall_score);
                        finalScoreValueElement.textContent = data.scores.overall_score.toFixed(1) + "점";

                        // 카테고리별 점수 표시
                        const scoresGrid = document.querySelector('#category-scores-details .scores-grid');
                        scoresGrid.innerHTML = '';

                        // 카테고리별 점수가 객체 형태로 존재하는 경우
                        if (data.scores && data.scores.category_scores_display && typeof data.scores.category_scores_display === 'object') {
                            Object.entries(data.scores.category_scores_display).forEach(([categoryName, score]) => {
                                console.log(`DEBUG: Displaying category: ${categoryName}, Score: ${score}`);
                                const scoreItem = document.createElement('div');
                                scoreItem.className = 'score-item';
                                scoreItem.innerHTML = `
                                    <div class="category-name">${categoryName}</div>
                                    <div class="score-value">${typeof score === 'number' ? score.toFixed(1) : 'N/A'} / 5.0</div>
                                `;
                                scoresGrid.appendChild(scoreItem);
                            });
                        } else {
                            console.error("DEBUG: category_scores_display data is missing or not an object:", data.scores);
                            const noScoresMessage = document.createElement('div');
                            noScoresMessage.className = 'no-scores-message';
                            noScoresMessage.textContent = '카테고리별 점수 정보를 불러오는 데 실패했습니다.';
                            scoresGrid.appendChild(noScoresMessage);
                        }
                        if (turnIndicator) turnIndicator.textContent = "대화 종료됨";
                        userInput.disabled = true;
                        sendButton.disabled = true;
                    } else {
                        userInput.disabled = false;
                        sendButton.disabled = false;
                    }

                } catch (error) {
                    console.error('Frontend: Error processing NORMAL command:', error);
                    const errorP = document.createElement('p');
                    errorP.textContent = `오류: ${error.message}`;
                    errorP.style.color = 'red';
                    chatBox.appendChild(errorP);
                }
            }
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        sendButton.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });
        tryAgainButton.addEventListener('click', () => {
            window.location.reload();
        });
    </script>
</body>
</html>